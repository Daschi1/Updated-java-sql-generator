/*
 *  Copyright 2012 Paul Merlin.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *  under the License.
 */
package org.sql.generation.implementation.transformation.sqlite;

import org.sql.generation.api.common.NullArgumentException;
import org.sql.generation.api.grammar.definition.schema.SchemaDefinition;
import org.sql.generation.api.grammar.definition.table.*;
import org.sql.generation.implementation.transformation.DefinitionProcessing.ColumnDefinitionProcessor;
import org.sql.generation.implementation.transformation.DefinitionProcessing.SchemaDefinitionProcessor;
import org.sql.generation.implementation.transformation.DefinitionProcessing.TableElementListProcessor;
import org.sql.generation.implementation.transformation.spi.SQLProcessorAggregator;

import java.util.Map;

public class DefinitionProcessing {

    public static class SQLListeTableElementListProcessor
            extends TableElementListProcessor {

        @Override
        protected void processTableElement(final SQLProcessorAggregator aggregator, final TableElement object,
                                           final StringBuilder builder, final boolean hasNext) {
            if (object.getImplementedType().isAssignableFrom(TableConstraintDefinition.class)) {
                final TableConstraint constraint =
                        ((TableConstraintDefinition) object).getConstraint();
                if (constraint.getImplementedType().isAssignableFrom(UniqueConstraint.class)) {
                    final UniqueConstraint unique = (UniqueConstraint) constraint;
                    if (UniqueSpecification.PRIMARY_KEY.equals(unique.getUniquenessKind())) {
                        return; // Skip the whole TableElement for SQL autogen support, see below
                    }
                }

            }
            super.processTableElement(aggregator, object, builder, hasNext);
        }

    }

    public static class SQLiteSchemaDefinitionProcessor
            extends SchemaDefinitionProcessor {

        @Override
        protected void doProcess(final SQLProcessorAggregator aggregator, final SchemaDefinition object,
                                 final StringBuilder builder) {
            // Just process schema elements
            this.processSchemaElements(aggregator, object, builder);
        }

    }

    public static class SQLiteColumnDefinitionProcessor
            extends ColumnDefinitionProcessor {

        private final Map<Class<?>, String> _autoGenDataTypes;

        public SQLiteColumnDefinitionProcessor(final Map<Class<?>, String> autoGenDataTypes) {
            NullArgumentException.validateNotNull("Data type serial names", autoGenDataTypes);
            this._autoGenDataTypes = autoGenDataTypes;
        }

        @Override
        protected void processDataType(final SQLProcessorAggregator aggregator, final ColumnDefinition object,
                                       final StringBuilder builder) {
            final AutoGenerationPolicy autoGenPolicy = object.getAutoGenerationPolicy();
            if (autoGenPolicy == null) {
                super.processDataType(aggregator, object, builder);
            } else {
                // SQLite can't handle the ALWAYS strategy
                if (AutoGenerationPolicy.BY_DEFAULT.equals(autoGenPolicy)) {
                    // SQLite MUST use INTEGER type when autogenerated
                    final Class<?> dtClass = object.getDataType().getClass();
                    Boolean success = false;
                    for (final Map.Entry<Class<?>, String> entry : this._autoGenDataTypes.entrySet()) {
                        success = entry.getKey().isAssignableFrom(dtClass);
                        if (success) {
                            builder.append(entry.getValue());
                            break;
                        }
                    }
                    if (!success) {
                        throw new UnsupportedOperationException("Unsupported column data type "
                                + object.getDataType()
                                + " for auto-generated column.");
                    }
                } else {
                    throw new UnsupportedOperationException("Unsupported auto generation policy: "
                            + autoGenPolicy
                            + ".");
                }
            }
        }

        @Override
        protected void processMayBeNull(final ColumnDefinition object, final StringBuilder builder) {
            // Nothing to do - auto generation policy handled in data type orc
        }

        @Override
        protected void processAutoGenerationPolicy(final ColumnDefinition object, final StringBuilder builder) {
            // Nothing to do - auto generation policy handled in data type orc
        }

    }

}
